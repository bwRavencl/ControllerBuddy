//file:noinspection GroovyAccessibility
//file:noinspection GroovyAssignabilityCheck
//file:noinspection GrUnresolvedAccess

import com.diffplug.spotless.extra.wtp.EclipseWtpFormatterStep
import com.github.spotbugs.snom.Confidence
import com.github.spotbugs.snom.Effort
import groovy.transform.Canonical
import groovy.xml.MarkupBuilder
import groovy.xml.XmlParser
import org.gradle.nativeplatform.platform.internal.Architectures
import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform
import org.xml.sax.helpers.DefaultHandler

plugins {
	id 'application'
	id 'com.diffplug.spotless' version '7.2.1'
	id 'com.github.spotbugs' version '6.2.2'
	id 'net.ltgt.errorprone' version '4.3.0'
	id 'org.gradlex.extra-java-module-info' version '1.13'
}

version = providers.exec {
	commandLine('git', 'describe', '--long', '--dirty=.dirty')
}.standardOutput.asText.get().trim().replaceFirst('-', '.').replaceFirst('-g', '-')

base {
	archivesName = application.applicationName.toLowerCase(Locale.ROOT)
}

application {
	mainModule = 'de.bwravencl.controllerbuddy'
	mainClass = 'de.bwravencl.controllerbuddy.gui.Main'
}

ext {
	javaLanguageVersion = JavaLanguageVersion.of(24)

	def launcher = javaToolchains.launcherFor {
		languageVersion.set(javaLanguageVersion)
	}
	javaHome = launcher.map { it.metadata.installationPath }

	os = DefaultNativePlatform.currentOperatingSystem

	moduleInfoFile = "$projectDir/src/main/java/module-info.java"
	constantsFile = "$projectDir/src/main/java/de/bwravencl/controllerbuddy/constants/Constants.java"

	resourcesDir = "$projectDir/src/main/resources"
	tmpDir = layout.buildDirectory.dir 'tmp'
	runtimeDir = tmpDir.map { it.dir 'runtime' }

	def mainModule = project.application.mainModule.get()
	commonJvmArgs = [
		'-XX:+UseSerialGC',
		'-Xms96m',
		'-Xmx96m',
		"--enable-native-access=$mainModule"
	]
	windowsJvmArgs = [
		"--add-opens=java.desktop/java.awt=$mainModule",
		"--add-opens=java.desktop/sun.awt.windows=$mainModule"
	]
	linuxJvmArgs = [
		"--add-opens=java.desktop/sun.awt=$mainModule",
		"--add-opens=java.desktop/sun.awt.X11=$mainModule"
	]

	gamecontrollerdbGitFile = "$projectDir/SDL_GameControllerDB/gamecontrollerdb.txt"
	gamecontrollerdbResFile = "$resourcesDir/gamecontrollerdb.txt"

	arch = DefaultNativePlatform.currentArchitecture
	distAppendix = "${os.toFamilyName()}-$arch.name"
}

repositories {
	mavenCentral()
	maven { url = 'https://central.sonatype.com/repository/maven-snapshots' }
}

java {
	toolchain {
		languageVersion = javaLanguageVersion
		vendor = JvmVendorSpec.AZUL
	}
}

dependencies {
	errorprone 'com.google.errorprone:error_prone_core:2.41.0'
	spotbugs 'com.github.spotbugs:spotbugs:4.9.3'

	def dbusJavaVersion = '5.1.1'
	def lwjglVersion = '3.4.0-SNAPSHOT'

	def lwjglOs
	if (os.windows) {
		lwjglOs = "windows"
	} else if (os.macOsX)
		lwjglOs = 'macos'
	else if (os.linux) {
		lwjglOs = 'linux'
	} else
		throw new GradleException("Unsupported operating system $os.displayName")

	def lwjglArch
	switch (arch.name) {
		case { Architectures.X86.isAlias(it) && os.windows }:
			lwjglArch = 'x86'
			break
		case { Architectures.X86_64.isAlias(it) }:
			lwjglArch = ''
			break
		case { Architectures.ARM_V7.isAlias(it) && os.linux }:
			lwjglArch = 'arm32'
			break
		case { Architectures.AARCH64.isAlias(it) }:
			lwjglArch = 'arm64'
			break
		default:
			throw new GradleException("Unsupported system architecture $arch.displayName")
	}

	def lwjglPlatform = "${lwjglOs}${lwjglArch.isEmpty() ? '' : '-'}${lwjglArch}"

	implementation 'commons-cli:commons-cli:1.9.0'
	implementation 'com.formdev:flatlaf:3.6.1'
	implementation("com.github.hypfvieh:dbus-java-core:$dbusJavaVersion") { exclude group: 'org.slf4j', module: 'slf4j-api' }
	implementation("com.github.hypfvieh:dbus-java-transport-native-unixsocket:$dbusJavaVersion") { exclude group: 'org.slf4j', module: 'slf4j-api' }
	implementation 'com.google.code.gson:gson:2.13.1'
	implementation 'io.github.classgraph:classgraph:4.8.180'
	implementation('org.apache.xmlgraphics:batik-swing:1.19') { exclude group: 'xml-apis', module: 'xml-apis' }
	implementation "org.lwjgl:lwjgl:$lwjglVersion"
	implementation "org.lwjgl:lwjgl:$lwjglVersion:natives-$lwjglPlatform"
	implementation "org.lwjgl:lwjgl-sdl:$lwjglVersion"
	implementation "org.lwjgl:lwjgl-sdl:$lwjglVersion:natives-$lwjglPlatform"
	implementation 'org.slf4j:slf4j-jdk14:2.0.17'
}

extraJavaModuleInfo {
	deriveAutomaticModuleNamesFromFileNames = true
	failOnMissingModuleInfo = false
}

spotless {
	encoding 'UTF-8'
	java {
		target 'src/main/java/de/bwravencl/**/*.java'
		targetExclude moduleInfoFile, constantsFile
		eclipse('4.33').configFile 'spotless.eclipseformat.xml'
		formatAnnotations()
		//noinspection GroovyAccessibility
		cleanthat().sourceCompatibility(project.extensions.getByType(JavaPluginExtension).sourceCompatibility.toString()).addMutators([
			'SafeButNotConsensual',
			'SafeButControversial'
		])
		importOrderFile 'spotless.importorder'
		removeUnusedImports()
		removeWildcardImports()
		licenseHeader '''\
			/* Copyright (C) $YEAR  Matteo Hausner
			 *
			 * This program is free software: you can redistribute it and/or modify
			 * it under the terms of the GNU General Public License as published by
			 * the Free Software Foundation, either version 3 of the License, or
			 * (at your option) any later version.
			 *
			 * This program is distributed in the hope that it will be useful,
			 * but WITHOUT ANY WARRANTY; without even the implied warranty of
			 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
			 * GNU General Public License for more details.
			 *
			 * You should have received a copy of the GNU General Public License
			 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
			 */

			'''.stripIndent()
		endWithNewline()
	}
	groovyGradle {
		target '*.gradle'
		greclipse()
		importOrder()
		endWithNewline()
	}
	format 'xml', {
		target '*.svg'
		eclipseWtp EclipseWtpFormatterStep.XML
	}
	format 'newlineAndTrailingWhitespace', {
		target '.github/**/*.yml', "$resourcesDir/**/*.properties", "$resourcesDir/**/*.svg".toString()
		endWithNewline()
		trimTrailingWhitespace()
	}
	format 'onlyNewline', {
		target 'LICENSE', '*.gitignore', '*.md', '*.txt', "$resourcesDir/**/*.txt".toString()
		targetExclude gamecontrollerdbResFile
		endWithNewline()
	}
}

spotbugs {
	baselineFile = file('spotbugs-baseline.xml')
	effort = Effort.valueOf('MAX')
	extraArgs = ['-maxRank', '20']
	onlyAnalyze = ['de.bwravencl.-']
	reportLevel = Confidence.valueOf('LOW')
}

tasks.register('cleanConstants', Delete) {
	outputs.upToDateWhen { false }
	description = "Removes the '$constantsFile' source file"
	delete constantsFile
}

tasks.register('cleanGameControllerDB', Delete) {
	outputs.upToDateWhen { false }
	description = "Removes the 'gamecontrollerdb.txt' file from the '$resourcesDir' directory"
	delete gamecontrollerdbResFile
}

tasks.register('cleanLibsDirectory', Delete) {
	outputs.upToDateWhen { false }
	description = "Removes the '${base.libsDirectory.get()}' directory"
	delete base.libsDirectory
}

tasks.register('cleanModuleInfo', Delete) {
	outputs.upToDateWhen { false }
	description = "Removes the '$moduleInfoFile' source file"
	delete moduleInfoFile
}

tasks.register('cleanRuntimeDir', Delete) {
	outputs.upToDateWhen { false }
	description = "Removes the '${runtimeDir.get()}' directory"
	delete runtimeDir
}

tasks.register('cleanTmpProjectDir', Delete) {
	outputs.upToDateWhen { false }
	description = "Removes the '${tmpDir.get().file(project.name)}' directory"
	delete tmpDir.get().file(project.name)
}

tasks.named('clean') {
	dependsOn cleanConstants, cleanGameControllerDB, cleanLibsDirectory, cleanModuleInfo, cleanRuntimeDir, cleanTmpProjectDir
}

@Canonical
final class Coordinate implements Comparable<Coordinate> {

	String group

	String artifactId

	String version

	@Override
	int compareTo(Coordinate other) {
		def result = group <=> other.group
		if (result != 0) {
			return result
		}
		result = artifactId <=> other.artifactId
		if (result != 0) {
			return result
		}
		return version <=> other.version
	}

	@Override
	String toString() {
		[group, artifactId, version].findAll { it }.join ':'
	}
}

@Canonical
final class DependencyMetadata {

	Coordinate coordinate

	List<License> licenses = []
}

@Canonical
final class License {

	String name

	String url
}

static buildNoLicenseException(String fileName) {
	new GradleException("No license metadata found for dependency: $fileName")
}

DependencyMetadata getLicensesForDependency(Coordinate coordinate, Coordinate initialCoordinate = coordinate) {
	def aliases = [(new License('Apache-2.0', 'https://www.apache.org/licenses/LICENSE-2.0')): [
			'Apache-2.0',
			'Apache License, Version 2.0',
			'The Apache License, Version 2.0',
			'The Apache Software License, Version 2.0'
		], (new License('MIT', 'https://opensource.org/license/mit/'))                           : [
			'MIT',
			'MIT License',
			'The MIT License (MIT)'
		]]
	def dependency = project.dependencies.create("$coordinate@pom")
	def pomConfiguration = project.configurations.detachedConfiguration(dependency)
	File pStream
	try {
		pStream = pomConfiguration.resolve().asList().first()
	} catch (ResolveException ignored) {
		throw buildNoLicenseException(coordinate)
	}
	def xmlParser = new XmlParser(true, false)
	xmlParser.setErrorHandler(new DefaultHandler())
	def node = xmlParser.parse(pStream)
	def dependencyMetadata = new DependencyMetadata(coordinate: initialCoordinate)
	node.licenses.license.each {
		def license = new License(it.name.text().trim(), it.url.text().trim())
		def alias = aliases.find { aliasEntry ->
			aliasEntry.value.any { aliasElem ->
				if (aliasElem instanceof String) {
					return aliasElem == license.name
				} else if (aliasElem instanceof License) {
					return (License) aliasElem == license
				}
			}
		}
		if (alias) {
			license = alias.key
		}
		dependencyMetadata.licenses << license
	}
	if (!dependencyMetadata.licenses.empty) {
		return dependencyMetadata
	} else if (node.parent.text()) {
		def parentCoordinate = new Coordinate(group: node.parent.groupId.text().trim(), artifactId: node.parent.artifactId.text().trim(), version: node.parent.version.text().trim())
		return getLicensesForDependency(parentCoordinate, initialCoordinate)
	}
	throw buildNoLicenseException(initialCoordinate)
}

def dependencyMetadataSet = configurations.runtimeClasspath.resolvedConfiguration.resolvedArtifacts.collect { resolvedArtifact ->
	def coordinate = new Coordinate(group: resolvedArtifact.moduleVersion.id.group, artifactId: resolvedArtifact.moduleVersion.id.name, version: resolvedArtifact.moduleVersion.id.version)
	getLicensesForDependency(coordinate)
}.toSet()

dependencyMetadataSet << new DependencyMetadata(coordinate: new Coordinate(artifactId: 'SDL_GameControllerDB'), licenses: [
	new License('zlib License', 'https://raw.githubusercontent.com/mdqinc/SDL_GameControllerDB/master/LICENSE')
])

tasks.register('generateConstants') {
	description = "Generates the '$constantsFile' source file"
	mustRunAfter cleanConstants
	def version = project.version
	def file = file constantsFile
	def applicationName = application.applicationName
	def licenseFile = layout.projectDirectory.file('LICENSE')
	doLast {
		def generateHtmlLicenseReport = {
			def stringWriter = new StringWriter()
			def markupBuilder = new MarkupBuilder(new IndentPrinter(stringWriter, '', false))
			markupBuilder.html {
				body {
					h1 "$applicationName License:"
					p {
						licenseFile.getAsFile().readLines().each {
							mkp.yield it.strip()
							br()
						}
					}
					br()
					h1 'Third-Party Licenses:'
					table {
						tr {
							th('align': 'left') { h3 'Dependency' }
							th('align': 'left') { h3 'License' }
							th('align': 'left') { h3 'Link' }
						}
						dependencyMetadataSet.sort { it.coordinate }.each { entry ->
							entry.licenses.each { license ->
								tr {
									td entry.coordinate
									td license.name
									td {
										if (license.url) {
											a(href: license.url, 'Open')
										}
									}
								}
							}
						}
					}
				}
			}
			stringWriter.toString()
		}
		file.getParentFile().mkdirs()
		file.write("""\
			package de.bwravencl.controllerbuddy.constants;\n
			public class Constants {

				public static final String APPLICATION_NAME = "$applicationName";

				public static final long BUILD_TIMESTAMP = ${System.currentTimeMillis()}L;

				public static final String VERSION = "$version";

				public static final String LICENSES_HTML;

				static {
					//noinspection HttpUrlsUsage
					LICENSES_HTML = "${generateHtmlLicenseReport().replace('"', '\\"')}";
				}
			}
			""".stripIndent(), 'UTF-8')
	}
}

tasks.register('generateModuleInfo') {
	description = "Generates the '$moduleInfoFile' source file"
	mustRunAfter cleanModuleInfo
	def file = file moduleInfoFile
	doLast {
		file.write('''\
			@SuppressWarnings({"requires-automatic", "Java9RedundantRequiresStatement"})
			module de.bwravencl.controllerbuddy {
			    exports de.bwravencl.controllerbuddy.gui;

			    opens de.bwravencl.controllerbuddy.input to com.google.gson;
			    opens de.bwravencl.controllerbuddy.input.action to com.google.gson;

			    requires com.google.gson;
			    requires com.formdev.flatlaf;
			    requires io.github.classgraph;
			    requires transitive java.desktop;
			    requires java.logging;
			    requires java.prefs;
			    requires jdk.xml.dom;
			    requires org.apache.commons.cli;
			    requires org.apache.xmlgraphics.batik.anim;
			    requires org.apache.xmlgraphics.batik.bridge;
			    requires org.apache.xmlgraphics.batik.constants;
			    requires org.apache.xmlgraphics.batik.dom;
			    requires org.apache.xmlgraphics.batik.util;
			    requires org.apache.xmlgraphics.batik.swing;
			    requires org.freedesktop.dbus;
			    requires org.lwjgl;
			    requires org.lwjgl.natives;
			    requires org.lwjgl.sdl;
			    requires org.lwjgl.sdl.natives;
			    requires xml.apis.ext;
			}
			'''.stripIndent(), 'UTF-8')
	}
}

tasks.withType(JavaCompile).configureEach {
	dependsOn generateModuleInfo, generateConstants
	source generateConstants.outputs.files, sourceSets.main.java
	options.encoding = 'UTF-8'
	gradle.taskGraph.whenReady {
		if (it.hasTask(jpackage)) {
			options.compilerArgs << '-Xlint:all' << '-Xlint:-preview' << '-Werror'
			options.deprecation = true
			options.errorprone.error 'MissingBraces'
		} else {
			options.errorprone.enabled = false
		}
	}
}

tasks.named('run') {
	jvmArgs += commonJvmArgs
	if (os.windows)
		jvmArgs += windowsJvmArgs
	else if (os.linux)
		jvmArgs += linuxJvmArgs
}

tasks.register('checkGameControllerDBSubmodule') {
	description = "Checks that the SDL_GameControllerDB submodule is checked out"
	def file = file gamecontrollerdbGitFile
	doLast {
		if (!file.exists()) {
			throw new GradleException("SDL_GameControllerDB submodule not checked out")
		}
	}
}

tasks.register('copyGameControllerDB', Copy) {
	description = "Places a copy of '${gamecontrollerdbGitFile}' into the '$resourcesDir' directory"
	dependsOn checkGameControllerDBSubmodule
	mustRunAfter cleanGameControllerDB
	from gamecontrollerdbGitFile
	into resourcesDir
}

tasks.named('processResources') {
	dependsOn copyGameControllerDB
}

tasks.register('copyLibs', Copy) {
	description = 'Copies all jar files into a directory called \'libs\' inside the build directory'
	dependsOn cleanLibsDirectory, jar
	from configurations.runtimeClasspath
	into base.libsDirectory
}

tasks.named('spotbugsMain') {
	reports {
		html { required.set true }
		xml { required.set true }
	}
}

tasks.named('spotbugsTest') {
	enabled = false
}

tasks.named('spotlessGroovyGradleCheck') {
	dependsOn copyGameControllerDB
}

tasks.named('spotlessNewlineAndTrailingWhitespace') {
	dependsOn copyGameControllerDB
}

tasks.named('spotlessOnlyNewline') {
	dependsOn copyGameControllerDB
}

tasks.named('spotlessXml') {
	dependsOn copyGameControllerDB
}

tasks.named('test') {
	enabled = false
}

tasks.register('jlink', Exec) {
	description = 'Executes the jlink command to create a customized minimal Java runtime inside the build directory'
	dependsOn check, jar, cleanRuntimeDir
	commandLine "${javaHome.get()}/bin/jlink", '--output', runtimeDir.get(), '--strip-debug', '--no-header-files', '--no-man-pages', '--strip-native-commands', '--add-modules', 'java.desktop,java.management,jdk.unsupported,java.logging,jdk.accessibility,jdk.net,jdk.security.auth,jdk.xml.dom'
}

tasks.register('customizeLoggingProperties') {
	description = 'Alters the default "logging.properties" configuration file of the Java runtime to include a FileHandler that logs to a logfile in the system\'s TEMP directory using SimpleFormatter with custom formatting'
	dependsOn jlink
	def file = runtimeDir.get().file 'conf/logging.properties'
	def projectName = project.name
	doLast {
		ant.propertyfile(file: file) {
			entry(key: 'handlers', value: 'java.util.logging.FileHandler, java.util.logging.ConsoleHandler')
			entry(key: 'java.util.logging.FileHandler.pattern', value: "%t/${projectName}.log")
			entry(key: 'java.util.logging.FileHandler.formatter', value: 'java.util.logging.SimpleFormatter')
			entry(key: 'java.util.logging.SimpleFormatter.format', value: '[%1$tY-%1$tm-%1$td %1$tk:%1$tM:%1$tS:%1$tL] %3$s: %5$s%6$s%n')
		}
	}
}

tasks.register('jpackage', Exec) {
	description = 'Executes the jpackage command to create a standalone application image packaged with a custom minimal Java runtime'
	dependsOn copyLibs, customizeLoggingProperties, cleanTmpProjectDir
	def commandLineParts = [
		"${javaHome.get()}/bin/jpackage",
		'--dest',
		tmpDir.get(),
		'--type',
		'app-image',
		'--name',
		project.name,
		'--runtime-image',
		runtimeDir.get(),
		'--module-path',
		base.libsDirectory.get(),
		'--module',
		"${project.application.mainModule.get()}/${project.application.mainClass.get()}",
		'--app-version',
		version.substring(0, version.indexOf('-')),
		'--icon',
		"$projectDir/icon.${os.windows ? 'ico' : 'png'}",
		'--copyright',
		"Copyright ${new Date().format 'yyyy'} Matteo Hausner",
		'--vendor',
		'Matteo Hausner',
		'--verbose'
	]
	doFirst {
		println commandLineParts
	}
	def jvmArgs = commonJvmArgs
	if (os.windows)
		jvmArgs += windowsJvmArgs
	else if (os.linux)
		jvmArgs += linuxJvmArgs
	jvmArgs.each { commandLineParts.addAll(['--java-options', it]) }
	commandLine commandLineParts
}

tasks.named('startScripts') {
	enabled = false
}

tasks.replace('distTar', Tar).configure {
	dependsOn jpackage
	from tmpDir
	include "$project.name${os.macOsX ? '.app' : ''}/**"
	archiveAppendix = distAppendix
	compression = Compression.GZIP
}

tasks.replace('distZip', Zip).configure {
	dependsOn jpackage
	from tmpDir
	include "$project.name${os.macOsX ? '.app' : ''}/**"
	archiveAppendix = distAppendix
}

tasks.replace('installDist', Sync).configure {
	dependsOn jpackage
	from tmpDir
	into layout.buildDirectory.dir('install')
	include "$project.name${os.macOsX ? '.app' : ''}/**"
}
